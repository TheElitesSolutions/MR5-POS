// DEPRECATED - This file is no longer used in the application
// It has been kept as a reference for potential future JWT integration
// Original implementation follows:

import jwt from "jsonwebtoken";
import { User } from "../types/index.js";
import { logger } from "./logger.js";

// Secure JWT secret validation - no fallback allowed
const JWT_SECRET = process.env.JWT_SECRET || "electron-pos-secret-dev";
const JWT_REFRESH_SECRET =
  process.env.JWT_REFRESH_SECRET || "electron-pos-refresh-secret-dev";

// In development, warn about using default secrets
if (process.env.NODE_ENV !== "development") {
  if (!process.env.JWT_SECRET || !process.env.JWT_REFRESH_SECRET) {
    logger.error(
      "CRITICAL: JWT_SECRET and JWT_REFRESH_SECRET environment variables must be set in production"
    );
    process.exit(1);
  }
} else {
  if (!process.env.JWT_SECRET || !process.env.JWT_REFRESH_SECRET) {
    logger.warn("Using default JWT secrets in development mode");
  }
}

// Token blacklist for logout invalidation
const tokenBlacklist = new Set<string>();

export interface JWTPayload {
  userId: string;
  username: string;
  role: string;
  type: "access" | "refresh";
  iat?: number;
  exp?: number;
}

export const generateAccessToken = (user: User): string => {
  const payload: JWTPayload = {
    userId: user.id,
    username: user.username,
    role: user.role,
    type: "access",
  };

  // Short expiry for access token - 1 hour
  return jwt.sign(payload, JWT_SECRET, { expiresIn: "1h" });
};

export const generateRefreshToken = (user: User): string => {
  const payload: JWTPayload = {
    userId: user.id,
    username: user.username,
    role: user.role,
    type: "refresh",
  };

  // Longer expiry for refresh token - 30 days
  return jwt.sign(payload, JWT_REFRESH_SECRET, { expiresIn: "30d" });
};

export const verifyToken = (
  token: string,
  type: "access" | "refresh" = "access"
): JWTPayload => {
  try {
    // Check if token is blacklisted
    if (tokenBlacklist.has(token)) {
      throw new Error("Token has been invalidated");
    }

    const secret = type === "access" ? JWT_SECRET : JWT_REFRESH_SECRET;
    const decoded = jwt.verify(token, secret) as JWTPayload;

    // Verify token type matches expected
    if (decoded.type !== type) {
      throw new Error("Invalid token type");
    }

    return decoded;
  } catch (error) {
    throw new Error("Invalid or expired token");
  }
};

/**
 * Invalidate a token (for logout)
 */
export const invalidateToken = (token: string): void => {
  tokenBlacklist.add(token);
};

/**
 * Generate token pair for user
 */
export const generateTokenPair = (
  user: User
): { accessToken: string; refreshToken: string } => {
  return {
    accessToken: generateAccessToken(user),
    refreshToken: generateRefreshToken(user),
  };
};

/**
 * Refresh access token using refresh token
 */
export const refreshAccessToken = (refreshToken: string): string => {
  try {
    const decoded = verifyToken(refreshToken, "refresh");

    // Create a minimal user object for token generation
    const user: Pick<User, "id" | "username" | "role"> = {
      id: decoded.userId,
      username: decoded.username,
      role: decoded.role as any, // Cast to UserRole enum
    };

    return generateAccessToken(user as User);
  } catch (error) {
    throw new Error("Invalid refresh token");
  }
};

/**
 * Invalidate all tokens for a user (for logout)
 */
export const invalidateUserTokens = (userId: string): void => {
  // In a real implementation, you might want to track tokens by user
  // For now, we'll just clear the blacklist periodically
  logger.info(`Invalidating tokens for user: ${userId}`);
};

/**
 * Get token expiration time
 */
export const getTokenExpiration = (token: string): Date | null => {
  try {
    const decoded = jwt.decode(token) as JWTPayload;
    if (decoded && decoded.exp) {
      return new Date(decoded.exp * 1000);
    }
    return null;
  } catch {
    return null;
  }
};

/**
 * Check if token is expired
 */
export const isTokenExpired = (token: string): boolean => {
  const expiration = getTokenExpiration(token);
  if (!expiration) return true;
  return expiration < new Date();
};

/**
 * Get token payload without verification (for expired tokens)
 */
export const decodeToken = (token: string): JWTPayload | null => {
  try {
    return jwt.decode(token) as JWTPayload;
  } catch {
    return null;
  }
};

// Legacy support - will be deprecated
export const generateToken = (user: User): string => {
  return generateAccessToken(user);
};
